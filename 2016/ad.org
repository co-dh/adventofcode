* Advent Of Code: Day 4
    [[http://adventofcode.com/2016/day/4][day 4]]
    #+BEGIN_QUOTE
    Each room consists of an encrypted name (lowercase letters separated by dashes) followed by a dash, 
	a sector ID, and a checksum in square brackets.
    A room is real (not a decoy) if the checksum is the five most common letters in the encrypted name, 
	in order, with ties broken by alphabetization. For example:
    #+END_QUOTE
	+ aaaaa-bbb-z-y-x-123[abxyz] is a real room because the most common letters are a (5), b (3), and then a tie between x, y, and z, which are listed alphabetically.
	+ a-b-c-d-e-f-g-h-987[abcde] is a real room because although the letters are all tied (1 of each), the first five are listed alphabetically.
	+ not-a-real-room-404[oarel] is a real room.
	+ totally-real-room-200[decoy] is not.

** Top 5 Common Letters 
*** Create an 1 element dictionary with key x and value 1
    #+BEGIN_SRC q 
      ele:  {enlist[x]!enlist 1} 
      ele "a"
    #+END_SRC

    #+RESULTS:
    : a| 1

*** Adding 2 dictionares.
     | 0N! will print x in compact form(k form) | x: 0N! ele "a"  | (,"a")!,1 |
     | assignment prevent it displayed again    | y: 0N! "ab"!3 2 | "ab"!3 2  |
     |                                          | foo: 0N! x + y  | "ab"!4 2  |
    #+TBLFM: $3='(qq $-1)

*** top5
   Now we can define a function that return 5 most common letters of strings
    | Description     | Function | ("aaa";"bbbbb"; "z";"y"; "x")                                                   |
    |-----------------+----------+---------------------------------------------------------------------------------|
    | concat          | raze     | "aaabbbbbzyx"                                                                   |
    |                 | ele each | ((,"a")!,1;(,"a")!,1;(,"a")!,1;(,"b")!,1;(,"b")!,1;(,"b")!,1;(,"b")!,1;(,"b").. |
    | add all dict    | sum      | "abzyx"!3 5 1 1 1                                                               |
    | group by value  | group    | 3 5 1!(,"a";,"b";"zyx")                                                         |
    | sort each value | asc each | 3 5 1!(`s#,"a";`s#,"b";`s#"xyz")                                                |
    |                 | keyval   | (3 5 1;(`s#,"a";`s#,"b";`s#"xyz"))                                              |
    |                 | swap     | ((`s#,"a";`s#,"b";`s#"xyz");3 5 1)                                              |
    |                 | .[!]     | (`s#,"a";`s#,"b";`s#"xyz")!3 5 1                                                |
    |                 | desc     | (`s#,"b";`s#,"a";`s#"xyz")!5 3 1                                                |
    |                 | key      | (`s#,"b";`s#,"a";`s#"xyz")                                                      |
    |                 | raze     | "baxyz"                                                                         |
    |                 | 5 #      | "baxyz"                                                                         |
    |-----------------+----------+---------------------------------------------------------------------------------|
    |                 | top5:    | {5 # raze key desc .[!] swap keyval asc each group sum ele each raze x}         |
    #+TBLFM: @>$3='(qq(qf $-1 @2$2..@-1$2 ))::$3='(qq (step @# $-1 @-1))
    
    We can verify
  | top5 -1 _ "-" vs "aaaaa-bbb-z-y-x-123[abxyz]"   | "abxyz" |
  | top5 -1 _ "-" vs "a-b-c-d-e-f-g-h-987[abcde]"   | "abcde" |
  | top5 -1 _ "-" vs "not-a-real-room-404[oarel]"   | "oarel" |
  | top5 -1 _ "-" vs "totally-real-room-200[decoy]" | "loart" |
  #+TBLFM: $2='(qq $1)


*** Checksum
    |   | Function           | ("aaaaa"; "bbb"; enlist["z"]; enlist["y"]; enlist["x"]; "123")              |
    |---+--------------------+-----------------------------------------------------------------------------|
    |   | fork               | (("aaaaa";"bbb";,"z";,"y";,"x";"123");("aaaaa";"bbb";,"z";,"y";,"x";"123")) |
    |   | prod[(-1_; last)]  | (("aaaaa";"bbb";,"z";,"y";,"x");"123")                                      |
    |   | prod[(top5; "I"$)] | ("abxyz";123i)                                                              |
    |   | 1 rotate           | (123i;"abxyz")                                                              |
    |---+--------------------+-----------------------------------------------------------------------------|
    |   | checksum:          | {1 rotate prod[(top5; "I"$)] prod[(-1_; last)] fork x}                      |
    #+TBLFM: @>$3='(qq(qf $-1 @2$2..@-1$2 ))::$3='(qq (step @# $-1 @-1))


*** Convert Match(~) To One Argument Of Tuple 
  | "abc" ~ "abc"       | 1b |
  | ~["abc";  "abc"]    | 1b |
  | .[~] ("abc"; "abc") | 1b |
  #+TBLFM: $2='(qq $1)
  
** Parse
    Given a string like above, we can parse it to 3 parts: encrypted name, sector, checksum
    |   | Function             | "aaaaa-bbb-z-y-x-123[abxyz]"                                                           |
    |---+----------------------+----------------------------------------------------------------------------------------|
    |   | -1 _                 | "aaaaa-bbb-z-y-x-123[abxyz"                                                            |
    |   | "[" vs               | ("aaaaa-bbb-z-y-x-123";"abxyz")                                                        |
    |   | prod[("-"vs; ::)]    | (("aaaaa";"bbb";,"z";,"y";,"x";"123");"abxyz")                                         |
    |   | prod[(checksum; ::)] | ((123i;"abxyz");"abxyz")                                                               |
    |   | associate            | (123i;("abxyz";"abxyz"))                                                               |
    |   | prod[(::; .[~])]     | (123i;1b)                                                                              |
    |   | .[*]                 | 123i                                                                                   |
    |---+----------------------+----------------------------------------------------------------------------------------|
    |   | parser:              | {.[*] prod[(::; .[~])] associate prod[(checksum; ::)] prod[("-"vs; ::)] "[" vs -1 _ x} |
    #+TBLFM: @>$3='(qq(qf $-1 @2$2..@-1$2 ))::$3='(qq (step @# $-1 @-1))

** Answer 

#+begin_src q :exports both 
  show t: read0 `:4.txt
#+end_src

#+RESULTS:
: "nzydfxpc-rclop-qwzhpc-qtylyntyr-769[oshgk]"
: "qzlozfhmf-bzmcx-bnzshmf-zbpthrhshnm-339[zmxdi]"
: "xtwtelcj-rclop-upwwjmply-zapcletzyd-743[itbds]"
: "mrxivrexmsrep-fewoix-ywiv-xiwxmrk-308[kzypw]"
: "ibghopzs-qobrm-difqvogwbu-142[lnrzo]"
: "irgyyolokj-xghhoz-lotgtiotm-228[vnmxd]"
: "foadouwbu-gqojsbusf-vibh-fsgsofqv-376[ymswi]"
: ..

#+BEGIN_SRC q :exports both
  sum 0N! parser each t 
#+END_SRC

#+RESULTS:
: 0 0 0 0 0 0 0 0 236 0 0 393 893 0 563 0 0 0 0 0 0 0 0 0 0 0 0 0 0 748 0 0 623..
: 158835i


