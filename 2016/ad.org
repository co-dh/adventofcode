* Advent Of Code: Day 4
    [[http://adventofcode.com/2016/day/4]day 4]
    #+BEGIN_QUOTE
    Each room consists of an encrypted name (lowercase letters separated by dashes) followed by a dash, 
	a sector ID, and a checksum in square brackets.
    A room is real (not a decoy) if the checksum is the five most common letters in the encrypted name, 
	in order, with ties broken by alphabetization. For example:
    #+END_QUOTE
	+ aaaaa-bbb-z-y-x-123[abxyz] is a real room because the most common letters are a (5), b (3), and then a tie between x, y, and z, which are listed alphabetically.
	+ a-b-c-d-e-f-g-h-987[abcde] is a real room because although the letters are all tied (1 of each), the first five are listed alphabetically.
	+ not-a-real-room-404[oarel] is a real room.
	+ totally-real-room-200[decoy] is not.

** Product of functions
*** Binary Product 
    A production of function f: A->B, g: a->b, is a function f*g:(A,a)->(B,b)
    #+BEGIN_SRC q
    prod2:{[f;g]{(f x[0]; g x[1])}}
    #+END_SRC

    #+RESULTS:

    | f:{x+1}        |     |
    | g:{x*2}        |     |
    | prod2[f;g] 2 2 | 3 4 |
    #+TBLFM: $2='(qq $-1)
    
    
*** Multiary Product
    Since binary product is associative, we can reduce it over a list of functions.
    | apply f to 2                       | f 2                                        | 3                                     |
    | is same as                         | f @ 2                                      | 3                                     |
    | @ is the apply function            | @[f;2]                                     | 3                                     |
    | . convert @ from 2 arguments to 1  | .[@] (f;2)                                 | 3                                     |
    | argument of a list of two elements |                                            |                                       |
    |------------------------------------+--------------------------------------------+---------------------------------------|
    | :: is id function {[x]x}           | fs: ({-1_x}; ::)                           | ({-1_x};::)                           |
    |                                    | a: ("ab"; "cd")                            | ("ab";"cd")                           |
    |                                    | pair: fs,' enlist each a                   | (({-1_x};"ab");(::;"cd"))             |
    |                                    | .[@] each pair                             | (,"a";"cd")                           |
    |                                    | prod:{[fs;a] .[@] each fs,' enlist each a} | {[fs;a] .[@] each fs,' enlist each a} |
    |------------------------------------+--------------------------------------------+---------------------------------------|
    | Example                            | prod[(f;g;f);] 2 2 2                       | 3 4 3                                 |
   #+TBLFM: $3='(qk $-1)


** Parse
    Given a string like above, we can parse it to 3 parts: encrypted name, sector, checksum
    |   | Function                          | "aaaaa-bbb-z-y-x-123[abxyz]"                                                         |
    |---+-----------------------------------+--------------------------------------------------------------------------------------|
    |   | "[" vs                            | ("aaaaa-bbb-z-y-x-123";"abxyz]")                                                     |
    |   | prod[("-"vs;{-1_x})]              | (("aaaaa";"bbb";,"z";,"y";,"x";"123");"abxyz")                                       |
    |   | {(top5 -1_x 0;"I"$last x 0; x 1)} | ("abxyz";123i;"abxyz")                                                               |
    |   | {x[1] * x[0]~x[2]}                | 123i                                                                                 |
    |---+-----------------------------------+--------------------------------------------------------------------------------------|
    |   | parser:                           | {{x[1] * x[0]~x[2]} {(top5 -1_x 0;"I"$last x 0; x 1)} prod[("-"vs;{-1_x})] "[" vs x} |
    #+TBLFM: @>$3='(qq(qf $-1 @2$2..@-1$2 ))::$3='(qq (step @# $-1 @-1))

 
** Top 5 Common Letters 

*** ele function: create one element dictionary with key x and value 1
    #+BEGIN_SRC q 
      / display 10 row at most
      \c 10 80 
      ele:  {enlist[x]!enlist 1} 
      ele "a"
    #+END_SRC

    #+RESULTS:
    : a| 1

*** You can add 2 dictionary.
     | 0N! will print x in compact form(k form) | x: 0N! ele "a"  | (,"a")!,1 |
     | assignment stop print y                  | y: 0N! "ab"!3 2 | "ab"!3 2  |
     | assign to foo so it's not displayed.     | foo: 0N! x + y  | "ab"!4 2  |
    #+TBLFM: $3='(qq $-1)

*** top5
   Now we can define a function that return 5 most common letters of strings
    | Description      | Function       | ("aaa";"bbbbb"; "z";"y"; "x")                                                   |
    |------------------+----------------+---------------------------------------------------------------------------------|
    | concat           | raze           | "aaabbbbbzyx"                                                                   |
    |                  | ele each       | ((,"a")!,1;(,"a")!,1;(,"a")!,1;(,"b")!,1;(,"b")!,1;(,"b")!,1;(,"b")!,1;(,"b").. |
    | add all dict     | sum            | "abzyx"!3 5 1 1 1                                                               |
    | group by value   | group          | 3 5 1!(,"a";,"b";"zyx")                                                         |
    |                  | asc each       | 3 5 1!(`s#,"a";`s#,"b";`s#"xyz")                                                |
    | sort desc by key | {x desc key x} | (`s#,"b";`s#,"a";`s#"xyz")                                                      |
    |                  | raze           | "baxyz"                                                                         |
    |                  | 5 #            | "baxyz"                                                                         |
    |------------------+----------------+---------------------------------------------------------------------------------|
    |                  | top5:          | {5 # raze {x desc key x} asc each group sum ele each raze x}                    |
    #+TBLFM: @>$3='(qq(qf $-1 @2$2..@-1$2 ))::$3='(qq (step @# $-1 @-1))
    
    We can verify
  | top5 -1 _ "-" vs "aaaaa-bbb-z-y-x-123[abxyz]"   | "abxyz" |
  | top5 -1 _ "-" vs "a-b-c-d-e-f-g-h-987[abcde]"   | "abcde" |
  | top5 -1 _ "-" vs "not-a-real-room-404[oarel]"   | "oarel" |
  | top5 -1 _ "-" vs "totally-real-room-200[decoy]" | "loart" |
  #+TBLFM: $2='(qq $1)

** Checksum
     | Function  | "aaaaa-bbb-z-y-x-123[abxyz]"     |
     |-----------+----------------------------------|
     | "[" vs    | ("aaaaa-bbb-z-y-x-123";"abxyz]") |
     | last      | "abxyz]"                         |
     | -1 _      | "abxyz"                          |
     |-----------+----------------------------------|
     | checksum: | {-1 _ last "[" vs x}             |
    #+TBLFM: @>$2='(qq (qf "top5: 0N! " @2$1..@-1$1 ))::$2='(qq (step @# $-1 @-1))

** Auxilary 

    #+begin_src q 
      show t: read0 `:4.txt
#+end_src

#+RESULTS:
: "nzydfxpc-rclop-qwzhpc-qtylyntyr-769[oshgk]"
: "qzlozfhmf-bzmcx-bnzshmf-zbpthrhshnm-339[zmxdi]"
: "xtwtelcj-rclop-upwwjmply-zapcletzyd-743[itbds]"
: "mrxivrexmsrep-fewoix-ywiv-xiwxmrk-308[kzypw]"
: "ibghopzs-qobrm-difqvogwbu-142[lnrzo]"
: "irgyyolokj-xghhoz-lotgtiotm-228[vnmxd]"
: "foadouwbu-gqojsbusf-vibh-fsgsofqv-376[ymswi]"
: ..

f: {
 ; d1: d pj/ {([k: enlist x] v: enlist 1)} each raze -1_ "-" vs x
 ; common : 5 # raze exec k from `v xdesc select asc k by v from d1 where v <> 0 
 ; ck: -1 _ last "[" vs x
 ; $[common ~ ck; "I"$ first "[" vs last "-" vs x ; 0]
 } 

